#!/usr/bin/env python3

# Copyright The OpenTelemetry Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from argparse import REMAINDER, ArgumentParser
from logging import getLogger
from os import environ, execl, getcwd
from os.path import abspath, dirname, pathsep
from re import sub
from shutil import which

### === pkg_resources が import されることにより、
### === pkg_resources 内の @call_aside 関数 ( _initialize, _initialize_master_working_set ) が実行される
from pkg_resources import iter_entry_points

from opentelemetry.instrumentation.version import __version__

_logger = getLogger(__name__)


def run() -> None:
    print("=== これが、auto_instrument の run() 関数の開始地点")
    parser = ArgumentParser(
        description="""
        opentelemetry-instrument automatically instruments a Python
        program and its dependencies and then runs the program.
        """,
        epilog="""
        Optional arguments (except for --help and --version) for opentelemetry-instrument
        directly correspond with OpenTelemetry environment variables. The
        corresponding optional argument is formed by removing the OTEL_ or
        OTEL_PYTHON_ prefix from the environment variable and lower casing the
        rest. For example, the optional argument --attribute_value_length_limit
        corresponds with the environment variable
        OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT.

        These optional arguments will override the current value of the
        corresponding environment variable during the execution of the command.
        """,
    )

    argument_otel_environment_variable = {}
    
    # これにより pkg_resources が呼び出されて、pkg_resources のなかで WorkingSet に distribution がセットされる
    """
    test_iter_entry_points = iter_entry_points(
        "opentelemetry_environment_variables"
    )
    """

    # 各エントリポイント( api, instrument, sdk に対して... )
    for entry_point in iter_entry_points(
        "opentelemetry_environment_variables"
    ):
        environment_variable_module = entry_point.load()

        for attribute in dir(environment_variable_module):
            if attribute.startswith("OTEL_"):
                argument = sub(r"OTEL_(PYTHON_)?", "", attribute).lower()

                parser.add_argument(
                    f"--{argument}",
                    required=False,
                )

                # 環境変数辞書に KeyVal を格納してる
                # argument_otel_environment_variable['logs_exporter] = "OTEL_LOGS_EXPORTER"  的な感じ
                argument_otel_environment_variable[argument] = attribute

    # この辺は CLI の説明文だな。parser はそれか
    parser.add_argument(
        "--version",
        help="print version information",
        action="version",
        version="%(prog)s " + __version__,
    )
    parser.add_argument("command", help="Your Python application.")
    parser.add_argument(
        "command_args",
        help="Arguments for your application.",
        nargs=REMAINDER,
    )

    args = parser.parse_args()

    # 環境変数に設定できる変数分だけ回している
    for argument, otel_environment_variable in (
        argument_otel_environment_variable
    ).items():
        # argument が 'logs_exporter' で、otel_environment_variable が "OTEL_LOGS_EXPORTER"
        value = getattr(args, argument)
        if value is not None:
            # 実行時に args があったら設定する
            # opentelemetry-instrument --exporter_otlp_traces_protocol=grpc flask run --port 8080
            # とすると、grpc が設定される
            environ[otel_environment_variable] = value
            
    print("🌱🌱🌱 初期設定時に設定される環境変数 === ")
    for key, val in environ.items():
        if key.startswith("OTEL_"):
            print(key, " = ", val)
    print("🌱🌱🌱")
        
    # None になってた
    python_path = environ.get("PYTHONPATH")

    if not python_path:
        python_path = []

    else:
        python_path = python_path.split(pathsep)

    # この時点で python_path は []
    
    cwd_path = getcwd() # /Users/zuck3rx/git/event/cndt2023-demo/misk/research-python

    # This is being added to support applications that are being run from their
    # own executable, like Django.
    # FIXME investigate if there is another way to achieve this
    if cwd_path not in python_path:
        python_path.insert(0, cwd_path) # ここで上の python path が設定される

    filedir_path = dirname(abspath(__file__))
    # /Users/zuck3rx/git/event/cndt2023-demo/misk/research-python/lib/python3.11/site-packages/opentelemetry/instrumentation/auto_instrumentation
    # print(filedir_path)

    python_path = [path for path in python_path if path != filedir_path]
    # ['/Users/zuck3rx/git/event/cndt2023-demo/misk/research-python']
    # print(python_path)

    python_path.insert(0, filedir_path)
    # ['/Users/zuck3rx/git/event/cndt2023-demo/misk/research-python/lib/python3.11/site-packages/opentelemetry/instrumentation/auto_instrumentation', '/Users/zuck3rx/git/event/cndt2023-demo/misk/research-python']
    # print(python_path)

    environ["PYTHONPATH"] = pathsep.join(python_path)
    # PYTHONPATH に /auto_instrumentatio を追加

    executable = which(args.command)
    # print(executable)
    # flask を実行していることを特定
    # つまり、ここで flask を再実行しているということか
    print("⭐️⭐️⭐️ executable の再実行だぜ！！: ", executable, executable, *args.command_args)
    print("\n")
    # ここで再実行することで、sitecustomize.py が実行されている...( process が再作成されるためらしい )
    # 再実行というか、元々 opentelemetry-instrument バイナリが実行されていて、それが、 python app.py に置き換わって実行される感じ
    # これにより、sitecustomize.py の実行がトリガーされる
    execl(executable, executable, *args.command_args)